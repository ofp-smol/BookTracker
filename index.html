<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BookTracker - Scan & Track Your Reading</title>
<meta name="theme-color" content="#cc5500">
<meta name="description" content="Scan, track, and review your reading journey">
<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">
<!-- iOS Support -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BookTracker">
<link rel="apple-touch-icon" href="icon-192.png">
<!-- Favicon -->
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
background: linear-gradient(135deg, #cc5500 0%, #1a1a1a 100%);
min-height: 100vh; color: #fff; font-weight: bold;
}
.container {
max-width: 500px; margin: 0 auto; background: #2a2a2a;
min-height: 100vh; box-shadow: 0 0 20px rgba(0,0,0,0.5);
}
.header {
background: linear-gradient(135deg, #cc5500 0%, #1a1a1a 100%);
color: white; padding: 20px; text-align: center;
}
.nav-tabs { display: flex; background: #1a1a1a; }
.nav-tab {
flex: 1; padding: 15px; text-align: center; background: none;
border: none; cursor: pointer; font-size: 14px; font-weight: bold;
color: #fff;
}
.nav-tab.active { background: #cc5500; color: white; border-bottom: 2px solid #fff; }
.tab-content { display: none; padding: 20px; min-height: calc(100vh - 160px); }
.tab-content.active { display: block; }
.scan-btn {
background: linear-gradient(135deg, #cc5500 0%, #1a1a1a 100%);
color: white; border: none; padding: 20px 40px; border-radius: 50px;
font-size: 18px; font-weight: bold; cursor: pointer; margin: 20px 0;
box-shadow: 0 4px 15px rgba(204, 85, 0, 0.4); width: 100%; max-width: 300px;
}
.camera-container {
position: relative; margin: 20px auto; max-width: 300px;
border-radius: 10px; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
aspect-ratio: 4/3; /* Fixed aspect ratio */
}
#video { 
width: 100%; 
height: 100%; 
display: block; 
object-fit: cover; /* Ensure video fills container properly */
}
.scan-overlay {
position: absolute; 
top: 50%; 
left: 50%; 
transform: translate(-50%, -50%);
width: 60%; /* Responsive width */
height: 30%; /* Responsive height */
border: 3px solid #cc5500; 
border-radius: 8px;
box-shadow: 0 0 0 2000px rgba(0,0,0,0.7); /* Large but finite shadow */
transition: all 0.3s ease;
pointer-events: none; /* Prevent interaction */
z-index: 10;
}
.scan-overlay::before {
content: '';
position: absolute;
top: -6px; left: -6px; right: -6px; bottom: -6px;
border: 2px solid transparent;
border-radius: 12px;
animation: scanPulse 2s infinite;
pointer-events: none;
}
@keyframes scanPulse {
0% { border-color: transparent; }
50% { border-color: rgba(204, 85, 0, 0.5); }
100% { border-color: transparent; }
}
.scan-status {
position: absolute;
bottom: 15px;
left: 50%;
transform: translateX(-50%);
background: rgba(0, 0, 0, 0.8);
color: white;
padding: 8px 16px;
border-radius: 20px;
font-size: 12px;
font-weight: bold;
transition: all 0.3s ease;
z-index: 20;
white-space: nowrap;
}
.scan-status.scanning {
background: rgba(204, 85, 0, 0.9) !important;
animation: scanPulse 2s infinite;
}
.scan-status.initializing {
background: rgba(255, 165, 0, 0.9) !important;
}
.scan-status.ready {
background: rgba(0, 150, 0, 0.9) !important;
}
.book-card {
background: #333333; border-radius: 15px; padding: 20px; margin-bottom: 20px;
box-shadow: 0 4px 15px rgba(0,0,0,0.3); color: white;
}
.book-info { display: flex; gap: 15px; margin-bottom: 15px; }
.book-cover {
width: 80px; height: 120px; object-fit: cover;
border-radius: 8px; background: #1a1a1a;
}
.book-details h3 { font-size: 16px; margin-bottom: 5px; color: white; font-weight: bold; }
.book-details p { font-size: 14px; color: #ccc; margin-bottom: 3px; font-weight: bold; }
.btn {
padding: 8px 16px; border: none; border-radius: 20px;
font-size: 12px; font-weight: bold; cursor: pointer; margin: 2px;
}
.btn-primary { background: #cc5500; color: white; }
.btn-success { background: #cc5500; color: white; }
.btn-warning { background: #666; color: white; }
.btn-danger { background: #1a1a1a; color: white; }
.progress-bar {
width: 100%; height: 8px; background: #1a1a1a;
border-radius: 4px; margin: 10px 0;
}
.progress-fill {
height: 100%; background: linear-gradient(90deg, #cc5500, #ff6600);
border-radius: 4px; transition: width 0.3s ease;
}
.notes-area {
width: 100%; min-height: 80px; padding: 10px;
border: 1px solid #555; border-radius: 8px; margin: 10px 0;
background: #1a1a1a; color: white; font-weight: bold;
}
.page-input { display: flex; align-items: center; gap: 10px; margin: 10px 0; color: white;
font-weight: bold; }
.page-input input {
width: 80px; padding: 5px 10px; border: 1px solid #555;
border-radius: 4px; text-align: center; background: #1a1a1a; color: white; font-weight: bold;
}
.status-badges { display: flex; gap: 5px; margin: 10px 0; }
.badge {
padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;
}
.badge-reading { background: #cc5500; color: white; }
.badge-finished { background: #cc5500; color: white; }
.badge-dnf { background: #666; color: white; }
.badge-recommend { background: #cc5500; color: white; }
.badge-not-recommend { background: #1a1a1a; color: white; }
.empty-state { text-align: center; padding: 60px 20px; color: white; font-weight: bold; }
.loading { text-align: center; padding: 40px; color: white; font-weight: bold; }
.spinner {
width: 40px; height: 40px; border: 4px solid #333;
border-top: 4px solid #cc5500; border-radius: 50%;
animation: spin 1s linear infinite; margin: 0 auto 20px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.error {
background: #1a1a1a; color: #cc5500; padding: 15px;
border-radius: 8px; margin: 20px 0; text-align: center; font-weight: bold;
border: 1px solid #cc5500;
}
.book-actions { display: flex; gap: 5px; flex-wrap: wrap; }
.install-banner {
position: fixed; bottom: 20px; left: 20px; right: 20px;
background: #cc5500; color: white; padding: 15px; border-radius: 10px;
display: none; align-items: center; justify-content: space-between;
box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1000;
}
.install-banner button {
background: white; color: #cc5500; border: none;
padding: 8px 16px; border-radius: 5px; font-weight: bold; cursor: pointer;
}
.camera-info {
background: #333; padding: 15px; border-radius: 8px; margin: 20px 0;
color: #ccc; font-size: 14px; text-align: center;
}
.manual-input-section {
background: #333; padding: 20px; border-radius: 8px; margin: 20px 0;
text-align: center;
}
.manual-input-section h3 {
color: #cc5500; margin-bottom: 15px;
}
.isbn-input {
width: 100%; max-width: 200px; padding: 10px; margin: 10px 0;
border: 1px solid #555; border-radius: 4px; text-align: center;
background: #1a1a1a; color: white; font-weight: bold; font-size: 16px;
}
.scanned-info {
background: #1a1a1a; padding: 10px; border-radius: 8px; margin: 10px 0;
font-size: 12px; color: #ccc; text-align: center;
}
.offline-indicator {
background: #666; color: white; padding: 10px; text-align: center;
font-size: 12px; display: none;
}
@media (max-width: 480px) {
.book-info { flex-direction: column; align-items: center; text-align: center; }
.book-actions { justify-content: center; }
.camera-container { max-width: 280px; }
.scan-overlay { width: 70%; height: 35%; }
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
</head>
<body>
<div class="container">
<div class="header">
<h1>üìö BookTracker</h1>
<p>Scan, track, and review your reading journey</p>
</div>
<div class="offline-indicator" id="offline-indicator">
üìµ You're offline. Some features may not work.
</div>
<div class="nav-tabs">
<button class="nav-tab active" data-tab="scan">üì± Scan</button>
<button class="nav-tab" data-tab="library">üìñ Library</button>
</div>
<div id="scan-tab" class="tab-content active">
<div style="text-align: center; padding: 40px 20px;">
<button class="scan-btn" id="scan-button">üì∑ Scan Book Barcode</button>
<p style="color: #666; font-size: 14px;">Point your camera at a book's barcode</p>
<div class="camera-info" id="camera-info" style="display: none;">
<p>üì± Please allow camera access when prompted</p>
<p>This lets the app scan book barcodes</p>
<p><small>üí° Hold steady and wait for the scanner to focus</small></p>
</div>
<div id="camera-container" class="camera-container" style="display: none;">
<video id="video" autoplay muted playsinline></video>
<div class="scan-overlay"></div>
<div class="scan-status">üîç Point camera at barcode</div>
</div>
<button id="stop-btn" class="btn btn-danger" style="display: none; margin-top: 10px;">Stop
Scanning</button>
<!-- Manual ISBN input section -->
<div class="manual-input-section">
<h3>üìù Manual ISBN Entry</h3>
<p style="color: #ccc; font-size: 12px; margin-bottom: 10px;">Enter ISBN if scanning doesn't
work</p>

<input type="text" id="manual-isbn" class="isbn-input" placeholder="Enter ISBN..."
maxlength="13">
<br>
<button class="btn btn-primary" id="manual-lookup-btn">üîç Look Up Book</button>
</div>
<div id="scan-result" style="display: none;">
<div class="loading">
<div class="spinner"></div>
<p>Looking up book information...</p>
</div>
</div>
</div>
</div>
<div id="library-tab" class="tab-content">
<div id="library-content">
<div class="empty-state">
<h3>Your library is empty</h3>
<p>Start by scanning your first book!</p>
</div>
</div>
</div>
</div>
<!-- PWA Install Banner -->
<div id="install-banner" class="install-banner">
<span>üì± Install BookTracker for easier access!</span>
<button id="install-btn">Install</button>
<button id="dismiss-install" style="background: transparent; color: white;">‚úï</button>
</div>
<script>
// Add debug mode at the beginning
const DEBUG_MODE = true; // Set to false for production

// Global variables with proper initialization
let quaggaDetectionHandler = null;
let currentStream = null;
let scanningActive = false;
let quaggaInitialized = false;
let isProcessingBarcode = false;
let books = [];
let deferredPrompt;
let lastScannedBarcode = null;
let lastScanTime = 0;
let eventListenerCleanup = [];

// Enhanced localStorage safety wrapper
const StorageManager = {
    isAvailable() {
        try {
            const test = '__storage_test__';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch (e) {
            return false;
        }
    },
    get(key, defaultValue = null) {
        if (!this.isAvailable()) {
            debugLog('localStorage not available, using memory fallback');
            return defaultValue;
        }
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
        } catch (error) {
            debugLog(`localStorage get error for key ${key}: ${error.message}`);
            return defaultValue;
        }
    },
    set(key, value) {
        if (!this.isAvailable()) {
            debugLog('localStorage not available, changes will not persist');
            return false;
        }
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        } catch (error) {
            if (error.name === 'QuotaExceededError') {
                debugLog('localStorage quota exceeded');
                showError('Storage full. Please remove some books to continue.');
            } else {
                debugLog(`localStorage set error for key ${key}: ${error.message}`);
            }
            return false;
        }
    }
};

// Debounce utility for input handlers
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Enhanced debug logging
function debugLog(message) {
    if (DEBUG_MODE) {
        console.log('BookTracker:', message);
    }
}

// Network status monitoring
function updateOfflineStatus() {
    const indicator = document.getElementById('offline-indicator');
    if (!navigator.onLine) {
        indicator.style.display = 'block';
    } else {
        indicator.style.display = 'none';
    }
}

// Check camera support
function checkCameraSupport() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showError('Camera not supported in this browser. Please use Chrome, Firefox, or Safari.');
        return false;
    }
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        showError('Camera requires HTTPS. Please access this app over HTTPS.');
        return false;
    }
    return true;
}

// Enhanced storage functions
function getStoredBooks() {
    return StorageManager.get('books', []);
}

function saveBooks() {
    const success = StorageManager.set('books', books);
    if (!success) {
        showError('Could not save books. Changes may be lost.');
    }
    return success;
}

// Input validation
function validateISBN(isbn) {
    const cleaned = isbn.replace(/\D/g, '');
    return cleaned.length >= 8 && cleaned.length <= 14;
}

function sanitizeInput(input) {
    return input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
        .replace(/[<>]/g, '');
}

// PWA Install Logic
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    document.getElementById('install-banner').style.display = 'flex';
});

// Register Service Worker with error handling
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
            .then(registration => {
                debugLog('SW registered successfully');
                // Listen for updates
                registration.addEventListener('updatefound', () => {
                    debugLog('New service worker version available');
                });
            })
            .catch(registrationError => {
                debugLog('SW registration failed: ' + registrationError);
            });
    });
}

// Fixed Quagga initialization with better detection settings
function startQuagga() {
    console.log('üîç startQuagga() called');
    console.log('üîç Quagga available:', typeof Quagga !== 'undefined');
    console.log('üîç quaggaInitialized:', quaggaInitialized);
    console.log('üîç scanningActive:', scanningActive);

    // Check if Quagga is loaded
    if (typeof Quagga === 'undefined') {
        console.error('‚ùå Quagga is not loaded');
        showError('Barcode scanner library failed to load. Please refresh the page.');
        return;
    }

    // Clean up any existing handler first
    if (quaggaDetectionHandler && typeof Quagga.offDetected === 'function') {
        try {
            Quagga.offDetected(quaggaDetectionHandler);
            console.log('‚úÖ Removed old Quagga handler');
        } catch (e) {
            console.error('‚ùå Error removing old Quagga handler:', e);
        }
        quaggaDetectionHandler = null;
    }

    // Prevent multiple initializations
    if (quaggaInitialized) {
        console.log('üîÑ Quagga already initialized, restarting...');
        try {
            Quagga.start();
            scanningActive = true;
            console.log('‚úÖ Quagga restarted successfully');

            // Update UI to show active scanning
            const status = document.querySelector('.scan-status');
            if (status) {
                status.textContent = 'üì± Position barcode in frame';
                status.className = 'scan-status scanning';
            }

            // Re-register the handler on the running instance
            quaggaDetectionHandler = async (data) => {
                console.log('üéØ Barcode detected in restarted instance:', data.codeResult.code);
                if (!scanningActive || isProcessingBarcode) return;
                const code = data.codeResult.code;
                try {
                    Quagga.stop();
                    scanningActive = false;
                    showScanSuccess();
                    await handleBarcodeDetected(code);
                } catch (error) {
                    console.error('‚ùå Error handling barcode in restart:', error);
                    isProcessingBarcode = false;
                }
            };
            
            // Use the correct method to register detection handler
            if (typeof Quagga.onDetected === 'function') {
                Quagga.onDetected(quaggaDetectionHandler);
            } else if (typeof Quagga.on === 'function') {
                Quagga.on('detected', quaggaDetectionHandler);
            } else {
                console.error('‚ùå No valid method to register Quagga detection handler');
                showError('Scanner event system not available');
                return;
            }
            
            console.log('‚úÖ Detection handler re-registered');
            return;
        } catch (error) {
            console.error('‚ùå Error restarting Quagga:', error);
            quaggaInitialized = false;
            // fallback to full init
        }
    }

    console.log('üöÄ Starting fresh Quagga initialization...');
    const cameraContainer = document.querySelector('#camera-container');
    if (!cameraContainer) {
        console.error('‚ùå Camera container not found');
        showError('Camera container not found');
        return;
    }

    console.log('‚úÖ Camera container found, initializing Quagga...');

    // Show initial scanning status
    const status = document.querySelector('.scan-status');
    if (status) {
        status.textContent = '‚è≥ Initializing scanner...';
        status.className = 'scan-status initializing';
    }

    try {
        Quagga.init({
            inputStream: {
                name: "Live",
                type: "LiveStream",
                target: cameraContainer,
                constraints: {
                    facingMode: "environment",
                    width: { ideal: 640, min: 480, max: 800 }, // Reduced resolution for better performance
                    height: { ideal: 480, min: 320, max: 600 }
                }
            },
            decoder: {
                readers: [
                    "ean_reader", 
                    "ean_8_reader", 
                    "code_128_reader", 
                    "code_39_reader",
                    "code_39_vin_reader",
                    "codabar_reader",
                    "upc_reader",
                    "upc_e_reader"
                ],
                debug: {
                    drawBoundingBox: DEBUG_MODE,
                    showFrequency: DEBUG_MODE,
                    drawScanline: DEBUG_MODE,
                    showPattern: DEBUG_MODE
                }
            },
            locate: true,
            locator: {
                patchSize: "medium",
                halfSample: false, // Better accuracy
                willReadFrequently: true // Fix canvas performance warning
            },
            frequency: 10, // Increased frequency for better detection
            numOfWorkers: 2, // Use multiple workers
            debug: {
                drawBoundingBox: DEBUG_MODE,
                showFrequency: DEBUG_MODE,
                drawScanline: DEBUG_MODE,
                showPattern: DEBUG_MODE
            }
        }, (err) => {
            console.log('üì° Quagga.init callback called');
            if (err) {
                console.error('‚ùå Quagga init error:', err);
                showError('Barcode scanner init failed: ' + err.message);
                quaggaInitialized = false;
                return;
            }

            console.log('‚úÖ Quagga initialized successfully');
            quaggaInitialized = true;

            // Create detection handler with better validation
            console.log('üéØ Creating detection handler...');
            quaggaDetectionHandler = async (data) => {
                console.log('üéØ Barcode detected:', data.codeResult.code);
                console.log('üéØ Detection confidence:', data.codeResult.decodedCodes);

                if (!scanningActive || isProcessingBarcode) {
                    console.log('‚è≠Ô∏è Ignoring detection (not active or already processing)');
                    return;
                }

                // Enhanced validation - check barcode quality and confidence
                if (!data.codeResult || !data.codeResult.code) {
                    console.log('‚ö†Ô∏è Invalid barcode data, ignoring');
                    return;
                }

                // Check if we have decoded codes for confidence
                const decodedCodes = data.codeResult.decodedCodes;
                if (decodedCodes && decodedCodes.length > 0) {
                    // Calculate average confidence
                    const avgConfidence = decodedCodes.reduce((sum, code) => sum + (code.error || 0), 0) / decodedCodes.length;
                    console.log('üéØ Average error rate:', avgConfidence);
                    
                    // Skip if error rate is too high (low confidence)
                    if (avgConfidence > 0.3) {
                        console.log('‚ö†Ô∏è Low confidence detection, ignoring');
                        return;
                    }
                }

                const code = data.codeResult.code;

                // Enhanced ISBN validation before processing
                const cleanedCode = code.replace(/\D/g, '');
                if (cleanedCode.length < 8 || cleanedCode.length > 14) {
                    console.log('‚ö†Ô∏è Invalid barcode length, ignoring:', code);
                    return;
                }

                // Additional validation - check for common false positives
                if (code.includes('000000') || code.includes('111111') || code.includes('123456')) {
                    console.log('‚ö†Ô∏è Likely false positive, ignoring:', code);
                    return;
                }

                try {
                    console.log('üõë Stopping Quagga...');
                    Quagga.stop();
                    scanningActive = false;
                    showScanSuccess();
                    console.log('üìñ Handling barcode...');
                    await handleBarcodeDetected(code);
                } catch (error) {
                    console.error('‚ùå Error handling barcode:', error);
                    isProcessingBarcode = false;
                    // Restart scanning on error
                    setTimeout(() => {
                        if (!scanningActive && quaggaInitialized) {
                            try {
                                Quagga.start();
                                scanningActive = true;
                            } catch (restartError) {
                                console.error('‚ùå Error restarting after error:', restartError);
                            }
                        }
                    }, 2000);
                }
            };

            // Use the correct method to register detection handler
            if (typeof Quagga.onDetected === 'function') {
                Quagga.onDetected(quaggaDetectionHandler);
                console.log('‚úÖ Detection handler registered using onDetected');
            } else if (typeof Quagga.on === 'function') {
                Quagga.on('detected', quaggaDetectionHandler);
                console.log('‚úÖ Detection handler registered using on');
            } else {
                console.error('‚ùå No valid method to register Quagga detection handler');
                showError('Scanner event system not available');
                return;
            }

            // Start scanning with delay to allow camera to focus
            setTimeout(() => {
                try {
                    console.log('‚ñ∂Ô∏è Starting Quagga after delay...');
                    Quagga.start();
                    scanningActive = true;
                    console.log('‚úÖ Quagga started successfully');

                    // Update status to show ready for scanning
                    if (status) {
                        status.textContent = 'üì± Position barcode in frame';
                        status.className = 'scan-status ready';
                    }
                } catch (startError) {
                    console.error('‚ùå Error starting Quagga:', startError);
                    quaggaInitialized = false;
                    showError('Failed to start barcode scanner: ' + startError.message);
                }
            }, 2000); // Keep longer delay for camera focus
        });
    } catch (initError) {
        console.error('‚ùå Error calling Quagga.init:', initError);
        showError('Failed to initialize barcode scanner: ' + initError.message);
    }
}

// Enhanced scanning cleanup
function stopScanning() {
    debugLog('Stopping camera...');
    scanningActive = false;
    isProcessingBarcode = false;

    // Proper Quagga cleanup with stored handler
    if (quaggaInitialized) {
        try {
            Quagga.stop();
            if (quaggaDetectionHandler) {
                // Use the correct method to remove detection handler
                if (typeof Quagga.offDetected === 'function') {
                    Quagga.offDetected(quaggaDetectionHandler);
                } else if (typeof Quagga.off === 'function') {
                    Quagga.off('detected', quaggaDetectionHandler);
                }
                quaggaDetectionHandler = null;
                debugLog('Quagga detection handler removed');
            }
            debugLog('Quagga stopped successfully');
        } catch (error) {
            debugLog('Error stopping Quagga: ' + error.message);
        }
    }
    quaggaInitialized = false;

    // Stop camera stream
    if (currentStream) {
        try {
            currentStream.getTracks().forEach(track => {
                track.stop();
                debugLog('Camera track stopped: ' + track.kind);
            });
            currentStream = null;
        } catch (error) {
            debugLog('Error stopping camera tracks: ' + error.message);
            currentStream = null;
        }
    }

    // UI cleanup
    document.getElementById('camera-info').style.display = 'none';
    document.getElementById('camera-container').style.display = 'none';
    document.getElementById('stop-btn').style.display = 'none';
    document.getElementById('scan-button').style.display = 'block';
    document.getElementById('scan-result').style.display = 'none';
}

// Initialize app with enhanced error handling
document.addEventListener('DOMContentLoaded', function() {
    debugLog('App initializing...');

    // Setup offline monitoring
    window.addEventListener('online', updateOfflineStatus);
    window.addEventListener('offline', updateOfflineStatus);
    updateOfflineStatus();

    if (!checkCameraSupport()) {
        return;
    }

    books = getStoredBooks();
    renderLibrary();

    // Navigation with cleanup
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('nav-tab')) {
            const newTab = e.target.getAttribute('data-tab');
            // Clean up when switching away from scan tab
            if (newTab !== 'scan' && scanningActive) {
                stopScanning();
            }
            switchTab(newTab);
        }
    });

    // Enhanced button event listeners
    const scanButton = document.getElementById('scan-button');
    const stopButton = document.getElementById('stop-btn');
    const manualLookupBtn = document.getElementById('manual-lookup-btn');
    const manualIsbnInput = document.getElementById('manual-isbn');

    if (scanButton) {
        scanButton.addEventListener('click', handleScanButtonClick);
    }

    if (stopButton) {
        stopButton.addEventListener('click', handleStopButtonClick);
    }

    if (manualLookupBtn) {
        manualLookupBtn.addEventListener('click', handleManualLookup);
    }

    if (manualIsbnInput) {
        manualIsbnInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleManualLookup();
            }
        });

        // Enhanced input validation
        manualIsbnInput.addEventListener('input', function(e) {
            let value = e.target.value.replace(/[^\d\-X]/gi, '');
            if (value.length > 13) {
                value = value.substring(0, 13);
            }
            e.target.value = value;
        });
    }

    // PWA install buttons
    document.getElementById('install-btn').addEventListener('click', async () => {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            debugLog('Install prompt result: ' + outcome);
            deferredPrompt = null;
            document.getElementById('install-banner').style.display = 'none';
        }
    });

    document.getElementById('dismiss-install').addEventListener('click', () => {
        document.getElementById('install-banner').style.display = 'none';
    });

    debugLog('App initialized successfully');
});

// Enhanced button handlers
function handleScanButtonClick(e) {
    e.preventDefault();
    console.log('üñ±Ô∏è Scan button clicked');
    if (!checkCameraSupport()) {
        console.log('‚ùå Camera support check failed');
        return;
    }

    if (!navigator.onLine) {
        console.log('‚ùå No internet connection');
        showError('Internet connection required for book lookup');
        return;
    }

    console.log('‚úÖ Starting scan process...');
    document.getElementById('camera-info').style.display = 'block';
    document.getElementById('camera-info').innerHTML = '<p>üîÑ Initializing camera...</p>';

    setTimeout(() => {
        console.log('‚è∞ Camera timeout reached, calling startScanning()');
        startScanning();
    }, 500);
}

function handleStopButtonClick(e) {
    e.preventDefault();
    debugLog('Stop button clicked');
    stopScanning();
}

// Enhanced manual lookup with validation
async function handleManualLookup() {
    const isbnInput = document.getElementById('manual-isbn');
    const rawIsbn = sanitizeInput(isbnInput.value.trim());

    if (!rawIsbn) {
        showError('Please enter an ISBN number');
        return;
    }

    const isbn = rawIsbn.replace(/\D/g, '');

    if (!validateISBN(isbn)) {
        showError('Please enter a valid ISBN (8-14 digits)');
        return;
    }

    if (!navigator.onLine) {
        showError('Internet connection required for book lookup');
        return;
    }

    debugLog('Manual ISBN lookup: ' + isbn);

    document.getElementById('scan-result').style.display = 'block';
    document.getElementById('scan-result').innerHTML = `
        <div class="loading">
            <div class="spinner"></div>
            <p>Looking up book information...</p>
            <div class="scanned-info">Manual lookup: ${isbn}</div>
        </div>
    `;

    try {
        await lookupBookByISBN(isbn, 'manual');
    } catch (error) {
        debugLog('Manual lookup error: ' + error.message);
        showError('Error looking up book. Check internet connection.');
        document.getElementById('scan-result').style.display = 'none';
    }
}

function switchTab(tabName) {
    // Clean up event listeners when switching tabs
    if (tabName !== 'library') {
        cleanupEventListeners();
    }

    document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

    document.querySelectorAll('.tab-content').forEach(content =>
        content.classList.remove('active'));
    document.getElementById(tabName + '-tab').classList.add('active');

    if (tabName === 'library') renderLibrary();
}

// Enhanced camera startup with better error handling
async function startScanning() {
    console.log('üìπ Starting camera access...');
    try {
        // Check if camera is supported first
        if (!navigator.mediaDevices?.getUserMedia) {
            throw new Error('Camera API not supported in this browser');
        }

        document.getElementById('camera-info').innerHTML = '<p>üîÑ Requesting camera access...</p>';

        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: { ideal: 'environment' },
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 }
            }
        });

        currentStream = stream;
        console.log('‚úÖ Camera access granted successfully');

        const video = document.getElementById('video');
        if (!video) {
            throw new Error('Video element not found');
        }

        video.srcObject = currentStream;

        // Enhanced video loading with better error handling
        await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Video load timeout'));
            }, 15000); // Increased timeout

            const onCanPlay = () => {
                clearTimeout(timeout);
                video.removeEventListener('canplay', onCanPlay);
                video.removeEventListener('loadedmetadata', onCanPlay);
                video.removeEventListener('error', onError);
                console.log('‚úÖ Video can play');

                // Additional check - wait for actual video dimensions
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    resolve();
                } else {
                    // Wait a bit more for video to be fully ready
                    setTimeout(() => {
                        if (video.videoWidth > 0 && video.videoHeight > 0) {
                            resolve();
                        } else {
                            reject(new Error('Video dimensions not available'));
                        }
                    }, 1000);
                }
            };

            const onError = (e) => {
                clearTimeout(timeout);
                video.removeEventListener('canplay', onCanPlay);
                video.removeEventListener('loadedmetadata', onCanPlay);
                video.removeEventListener('error', onError);
                reject(new Error('Video load error: ' + (e.message || 'Unknown video error')));
            };

            video.addEventListener('canplay', onCanPlay);
            video.addEventListener('loadedmetadata', onCanPlay); // Additional event
            video.addEventListener('error', onError);
        });

        document.getElementById('camera-info').style.display = 'none';
        document.getElementById('camera-container').style.display = 'block';
        document.getElementById('stop-btn').style.display = 'block';
        document.getElementById('scan-button').style.display = 'none';

        // Start Quagga after camera is ready with increased delay
        setTimeout(() => {
            console.log('‚è∞ Quagga timeout reached, calling startQuagga()');
            startQuagga();
        }, 2000); // Increased from 1000ms to 2000ms

    } catch (error) {
        console.error('üìπ Camera error occurred:', error.name, '-', error.message);
        console.error('üìπ Full camera error:', error);
        document.getElementById('camera-info').style.display = 'none';

        // Enhanced error messages
        const errorMessages = {
            NotAllowedError: '‚ùå Camera permission denied. Please allow camera access and try again.',
            NotFoundError: '‚ùå No camera found on this device.',
            NotSupportedError: '‚ùå Camera not supported on this device.',
            NotReadableError: '‚ùå Camera is being used by another application.',
            OverconstrainedError: '‚ùå Camera constraints could not be satisfied.',
            SecurityError: '‚ùå Camera access blocked by security policy. Please use HTTPS.',
            AbortError: '‚ùå Camera access was aborted.',
            TypeError: '‚ùå Network error occurred while accessing camera.'
        };

        const message = errorMessages[error.name] || `‚ùå Camera error: ${error.message}. Try refreshing the page.`;
        showError(message);

        // Don't let this error bubble up to the global handler
        return; // Important: return here instead of throwing
    }
}

// Enhanced scan success feedback
function showScanSuccess() {
    const overlay = document.querySelector('.scan-overlay');
    const status = document.querySelector('.scan-status');

    if (overlay) {
        overlay.style.borderColor = '#00ff00';
        overlay.style.borderWidth = '4px';
        overlay.style.boxShadow = '0 0 30px #00ff00, 0 0 0 9999px rgba(0,255,0,0.1)';
    }

    if (status) {
        status.textContent = '‚úÖ Barcode Found!';
        status.style.background = 'rgba(0, 255, 0, 0.9)';
    }

    setTimeout(() => {
        if (overlay) {
            overlay.style.borderColor = '#cc5500';
            overlay.style.borderWidth = '2px';
            overlay.style.boxShadow = '0 0 0 9999px rgba(0,0,0,0.7)';
        }
        if (status) {
            status.textContent = 'üîç Point camera at barcode';
            status.style.background = 'rgba(0, 0, 0, 0.8)';
        }
    }, 2000);

    // Enhanced feedback
    if (navigator.vibrate) {
        navigator.vibrate([200, 100, 200]);
    }

    // Enhanced audio feedback with error handling
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
    } catch (error) {
        debugLog('Audio feedback failed: ' + error.message);
    }
}

// Enhanced barcode handling with race condition prevention
async function handleBarcodeDetected(barcode) {
    // Prevent race conditions
    if (isProcessingBarcode) {
        debugLog('Already processing a barcode, ignoring duplicate');
        return;
    }
    isProcessingBarcode = true;

    try {
        const cleanedISBN = barcode.replace(/\D/g, '');

        // Enhanced duplicate detection
        if (lastScannedBarcode === barcode && Date.now() - lastScanTime < 3000) {
            debugLog('Duplicate barcode detected within 3 seconds, ignoring');
            return;
        }

        lastScannedBarcode = barcode;
        lastScanTime = Date.now();

        debugLog('Processing barcode: ' + barcode);
        console.log('‚úÖ PROCESSING ISBN:', cleanedISBN);

        // Validate ISBN before processing
        if (!validateISBN(cleanedISBN)) {
            showError('Invalid barcode format. Please try scanning again or enter ISBN manually.');
            return;
        }

        document.getElementById('scan-result').style.display = 'block';
        document.getElementById('scan-result').innerHTML = `
            <div class="loading">
                <div class="spinner"></div>
                <p>Looking up book information...</p>
                <div class="scanned-info">
                    <strong>Scanned:</strong> ${barcode}<br>
                    <strong>ISBN:</strong> ${cleanedISBN}<br>
                    <strong>Length:</strong> ${cleanedISBN.length} digits
                </div>
            </div>
        `;

        await lookupBookByISBN(cleanedISBN, 'scanned', barcode);

    } catch (error) {
        debugLog('Book lookup error: ' + error.message);
        showError('Error looking up book. Check internet connection.');
        setTimeout(() => {
            document.getElementById('scan-result').style.display = 'none';
        }, 3000);
    } finally {
        isProcessingBarcode = false;
    }
}

// Enhanced book lookup with timeout and retry logic
async function lookupBookByISBN(isbn, source, originalBarcode = null) {
    debugLog(`Looking up ISBN: ${isbn}`);
    console.log('üîç API LOOKUP - ISBN:', isbn, 'Source:', source, 'Original:', originalBarcode);

    let bookData = null;
    const sources = [
        { name: 'Google Books', func: fetchBookFromGoogle },
        { name: 'OpenLibrary', func: fetchBookFromOpenLibrary }
    ];

    for (const sourceInfo of sources) {
        if (!bookData && navigator.onLine) {
            debugLog(`Trying ${sourceInfo.name}...`);
            try {
                bookData = await sourceInfo.func(isbn);
                if (bookData) {
                    debugLog(`‚úÖ Found book in ${sourceInfo.name}`);
                    bookData.source = sourceInfo.name;
                    break;
                }
            } catch (error) {
                debugLog(`‚ùå ${sourceInfo.name} failed: ${error.message}`);
                // Show specific error for network issues
                if (error.message.includes('timeout') || error.message.includes('Network')) {
                    showError(`${sourceInfo.name} is slow to respond. Trying alternate source...`);
                }
            }
        }
    }

    if (bookData) {
        bookData.scanInfo = {
            source: source,
            originalBarcode: originalBarcode,
            cleanedISBN: isbn,
            timestamp: new Date().toISOString(),
            foundIn: bookData.source
        };
        displayBookPreview(bookData);
    } else {
        const errorMsg = !navigator.onLine
            ? 'No internet connection. Please check your network and try again.'
            : source === 'manual'
            ? `No book found for ISBN: ${isbn}. This might be a region-specific edition or the ISBN might not be in our databases.`
            : 'Book not found in any database. Try manual entry or a different barcode.';

        showError(errorMsg);

        if (source === 'scanned') {
            setTimeout(() => {
                document.getElementById('scan-result').style.display = 'none';
            }, 4000);
        } else {
            document.getElementById('scan-result').style.display = 'none';
        }
    }
}

// Enhanced Google Books API with timeout and error handling
async function fetchBookFromGoogle(isbn) {
    const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout

   try {
       const url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`;
       console.log('üì° Google Books API call:', url);

       const response = await fetch(url, {
           signal: controller.signal,
           headers: {
               'Accept': 'application/json',
           }
       });

       clearTimeout(timeoutId);

       if (!response.ok) {
           throw new Error(`Google Books API error: ${response.status} ${response.statusText}`);
       }

       const data = await response.json();
       console.log('üì° Google Books Response:', data);

       if (data.items && data.items.length > 0) {
           const book = data.items[0].volumeInfo;
           const result = {
               isbn: isbn,
               title: sanitizeInput(book.title || 'Unknown Title'),
               authors: book.authors ? book.authors.map(a => sanitizeInput(a)) : ['Unknown Author'],
               pageCount: book.pageCount || 0,
               coverUrl: book.imageLinks?.thumbnail?.replace('http:', 'https:') || '',
               publishedDate: sanitizeInput(book.publishedDate || 'Unknown')
           };
           console.log('üìö Google Books Result:', result);
           return result;
       }
       return null;
   } catch (error) {
       clearTimeout(timeoutId);
       if (error.name === 'AbortError') {
           throw new Error('Request timeout - please check your internet connection');
       } else if (error.name === 'TypeError') {
           throw new Error('Network error - please check your internet connection');
       } else {
           throw new Error(`Google Books lookup failed: ${error.message}`);
       }
   }
}

// Enhanced OpenLibrary API with timeout and error handling
async function fetchBookFromOpenLibrary(isbn) {
   const controller = new AbortController();
   const timeoutId = setTimeout(() => controller.abort(), 12000); // 12s timeout (OpenLibrary is slower)

   try {
       const url = `https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`;
       console.log('üì° OpenLibrary API call:', url);

       const response = await fetch(url, {
           signal: controller.signal,
           headers: {
               'Accept': 'application/json',
           }
       });

       clearTimeout(timeoutId);

       if (!response.ok) {
           throw new Error(`OpenLibrary API error: ${response.status} ${response.statusText}`);
       }

       const data = await response.json();
       console.log('üì° OpenLibrary Response:', data);

       const bookKey = `ISBN:${isbn}`;
       if (data[bookKey]) {
           const book = data[bookKey];
           const result = {
               isbn: isbn,
               title: sanitizeInput(book.title || 'Unknown Title'),
               authors: book.authors ? book.authors.map(a => sanitizeInput(a.name)) : ['Unknown Author'],
               pageCount: book.number_of_pages || 0,
               coverUrl: book.cover?.medium || '',
               publishedDate: sanitizeInput(book.publish_date || 'Unknown')
           };
           console.log('üìö OpenLibrary Result:', result);
           return result;
       }
       return null;
   } catch (error) {
       clearTimeout(timeoutId);
       if (error.name === 'AbortError') {
           throw new Error('Request timeout - OpenLibrary is slow, please try again');
       } else if (error.name === 'TypeError') {
           throw new Error('Network error - please check your internet connection');
       } else {
           throw new Error(`OpenLibrary lookup failed: ${error.message}`);
       }
   }
}

// Enhanced book preview display
function displayBookPreview(bookData) {
   const scanInfoHtml = bookData.scanInfo ? `
       <div class="scanned-info">
           üìä ${bookData.scanInfo.source === 'manual' ? 'Manual entry' :
               bookData.scanInfo.source === 'test' ? 'Test scan' : 'Scanned'}:
           ${bookData.scanInfo.originalBarcode ?
               `${bookData.scanInfo.originalBarcode} ‚Üí ` : ''}
           ISBN: ${bookData.scanInfo.cleanedISBN}
           ${bookData.scanInfo.foundIn ?
               ` ‚Ä¢ Found in: ${bookData.scanInfo.foundIn}` : ''}
       </div>
   ` : '';

   // Enhanced cover image with lazy loading and error handling
   const coverImg = bookData.coverUrl ?
       `<img src="${bookData.coverUrl}" alt="${bookData.title}" class="book-cover" loading="lazy" onerror="this.style.display='none'">` :
       `<div class="book-cover" style="display:flex;align-items:center;justify-content:center;color:#666;">üìñ</div>`;

   document.getElementById('scan-result').innerHTML = `
       <div class="book-card">
           ${scanInfoHtml}
           <div class="book-info">
               ${coverImg}
               <div class="book-details">
                   <h3>${bookData.title}</h3>
                   <p><strong>Author:</strong> ${bookData.authors.join(', ')}</p>
                   <p><strong>Pages:</strong> ${bookData.pageCount || 'Unknown'}</p>
                   <p><strong>Published:</strong> ${bookData.publishedDate}</p>
               </div>
           </div>
           <div class="book-actions">
               <button class="btn btn-primary" id="add-book-btn">üìö Add to Library</button>
               <button class="btn btn-warning" id="continue-scan-btn">üîÑ Scan Another</button>
               <button class="btn btn-danger" id="wrong-book-btn">‚ùå Wrong Book</button>
           </div>
       </div>
   `;

   // Add event listeners with error handling
   const addBtn = document.getElementById('add-book-btn');
   const continueBtn = document.getElementById('continue-scan-btn');
   const wrongBtn = document.getElementById('wrong-book-btn');

   if (addBtn) addBtn.addEventListener('click', () => addBookToLibrary(bookData));
   if (continueBtn) continueBtn.addEventListener('click', continueScanningAfterPreview);
   if (wrongBtn) wrongBtn.addEventListener('click', handleWrongBook);
}

function handleWrongBook() {
   document.getElementById('scan-result').style.display = 'none';
   const manualInput = document.getElementById('manual-isbn');
   if (manualInput) {
       manualInput.value = '';
   }
   showError('Book lookup cancelled. Try scanning a different barcode or check the ISBN manually.');
}

// Enhanced add book with duplicate checking
function addBookToLibrary(bookData) {
   if (books.find(book => book.isbn === bookData.isbn)) {
       showError('This book is already in your library!');
       return;
   }

   const newBook = {
       ...bookData,
       id: Date.now(),
       currentPage: 0,
       status: 'reading',
       notes: '',
       recommendation: null,
       dateAdded: new Date().toISOString()
   };

   delete newBook.scanInfo;

   books.push(newBook);
   const saved = saveBooks();

   if (saved) {
       stopScanning();
       const manualInput = document.getElementById('manual-isbn');
       if (manualInput) {
           manualInput.value = '';
       }
       switchTab('library');
       showSuccess('Book added to your library!');
   }
}

function continueScanningAfterPreview() {
   document.getElementById('scan-result').style.display = 'none';
   const manualInput = document.getElementById('manual-isbn');
   if (manualInput) {
       manualInput.value = '';
   }

   // Reset processing flag and restart scanning
   isProcessingBarcode = false;
   setTimeout(() => {
       if (!scanningActive && quaggaInitialized) {
           startQuagga();
       }
   }, 500);
}

// Enhanced event listener cleanup
function cleanupEventListeners() {
   eventListenerCleanup.forEach(cleanup => {
       try {
           cleanup();
       } catch (error) {
           debugLog('Error during event listener cleanup: ' + error.message);
       }
   });
   eventListenerCleanup.length = 0;
}

// Enhanced library rendering with proper event management
function renderLibrary() {
   const libraryContent = document.getElementById('library-content');

   // Clean up previous event listeners
   cleanupEventListeners();

   if (books.length === 0) {
       libraryContent.innerHTML = `
           <div class="empty-state">
               <h3>Your library is empty</h3>
               <p>Start by scanning your first book!</p>
           </div>
       `;
       return;
   }

   const booksHtml = books.map(book => {
       const progress = book.pageCount > 0 ? (book.currentPage / book.pageCount) * 100 : 0;

       const coverImg = book.coverUrl ?
           `<img src="${book.coverUrl}" alt="${book.title}" class="book-cover" loading="lazy" onerror="this.style.display='none'">` :
           `<div class="book-cover" style="display:flex;align-items:center;justify-content:center;color:#666;">üìñ</div>`;

       return `
           <div class="book-card" data-book-id="${book.id}">
               <div class="book-info">
                   ${coverImg}
                   <div class="book-details">
                       <h3>${book.title}</h3>
                       <p><strong>Author:</strong> ${book.authors.join(', ')}</p>
                       ${book.pageCount > 0 ? `<p><strong>Progress:</strong> ${book.currentPage} / ${book.pageCount} pages</p>` : ''}
                   </div>
               </div>
               ${book.pageCount > 0 ? `<div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>` : ''}
               <div class="status-badges">
                   <span class="badge badge-${book.status}">
                       ${book.status === 'reading' ? 'üìñ Reading' : book.status === 'finished' ? '‚úÖ Finished' : '‚è∏ DNF'}
                   </span>
                   ${book.recommendation ? `<span class="badge badge-${book.recommendation}">${book.recommendation === 'recommend' ? 'üëç Recommend' : 'üëé Not Recommend'}</span>` : ''}
               </div>
               <div class="page-input">
                   <label>Current Page:</label>
                   <input type="number" class="page-input-field" value="${book.currentPage}" min="0" max="${book.pageCount || 9999}">
                   ${book.pageCount > 0 ? `<span>/ ${book.pageCount}</span>` : ''}
               </div>
               <textarea class="notes-area" placeholder="Add your reading notes...">${book.notes}</textarea>
               <div class="book-actions">
                   <button class="btn status-btn ${book.status === 'reading' ? 'btn-primary' : 'btn-warning'}" data-status="reading">üìñ Reading</button>
                   <button class="btn status-btn ${book.status === 'finished' ? 'btn-success' : 'btn-warning'}" data-status="finished">‚úÖ Finished</button>
                   <button class="btn status-btn ${book.status === 'dnf' ? 'btn-warning' : 'btn-danger'}" data-status="dnf">‚è∏ DNF</button>
                   <button class="btn rec-btn ${book.recommendation === 'recommend' ? 'btn-success' : 'btn-warning'}" data-recommendation="recommend">üëç Recommend</button>
                   <button class="btn rec-btn ${book.recommendation === 'not-recommend' ? 'btn-danger' : 'btn-warning'}" data-recommendation="not-recommend">üëé Not Recommend</button>
                   <button class="btn btn-danger remove-btn">üóë Remove</button>
               </div>
           </div>
       `;
   }).join('');

   libraryContent.innerHTML = booksHtml;

   // Add event listeners with proper cleanup tracking
   document.querySelectorAll('.book-card').forEach(card => {
       const bookId = parseInt(card.getAttribute('data-book-id'));

       // Create debounced handlers
       const debouncedPageUpdate = debounce((value) => updateBookPage(bookId, value), 500);
       const debouncedNotesUpdate = debounce((value) => updateBookNotes(bookId, value), 1000);

       // Page input handler
       const pageHandler = (e) => debouncedPageUpdate(e.target.value);
       const pageInput = card.querySelector('.page-input-field');
       if (pageInput) {
           pageInput.addEventListener('input', pageHandler);
           eventListenerCleanup.push(() => pageInput.removeEventListener('input', pageHandler));
       }

       // Notes handler
       const notesHandler = (e) => debouncedNotesUpdate(e.target.value);
       const notesArea = card.querySelector('.notes-area');
       if (notesArea) {
           notesArea.addEventListener('input', notesHandler);
           eventListenerCleanup.push(() => notesArea.removeEventListener('input', notesHandler));
       }

       // Status buttons
       card.querySelectorAll('.status-btn').forEach(btn => {
           const statusHandler = (e) => updateBookStatus(bookId, e.target.getAttribute('data-status'));
           btn.addEventListener('click', statusHandler);
           eventListenerCleanup.push(() => btn.removeEventListener('click', statusHandler));
       });

       // Recommendation buttons
       card.querySelectorAll('.rec-btn').forEach(btn => {
           const recHandler = (e) => updateBookRecommendation(bookId, e.target.getAttribute('data-recommendation'));
           btn.addEventListener('click', recHandler);
           eventListenerCleanup.push(() => btn.removeEventListener('click', recHandler));
       });

       // Remove button
       const removeBtn = card.querySelector('.remove-btn');
       if (removeBtn) {
           const removeHandler = () => removeBook(bookId);
           removeBtn.addEventListener('click', removeHandler);
           eventListenerCleanup.push(() => removeBtn.removeEventListener('click', removeHandler));
       }
   });
}

// Enhanced book update functions with validation
function updateBookPage(bookId, newPage) {
   const book = books.find(b => b.id === bookId);
   if (book) {
       const pageNum = Math.max(0, parseInt(newPage) || 0);

       // Validate page number
       if (book.pageCount > 0 && pageNum > book.pageCount) {
           book.currentPage = book.pageCount;
       } else {
           book.currentPage = pageNum;
       }

       // Auto-update status when finished
       if (book.pageCount > 0 && book.currentPage >= book.pageCount) {
           book.status = 'finished';
       }

       if (saveBooks()) {
           renderLibrary();
       }
   }
}

function updateBookNotes(bookId, notes) {
   const book = books.find(b => b.id === bookId);
   if (book) {
       book.notes = sanitizeInput(notes);
       saveBooks();
   }
}

function updateBookStatus(bookId, status) {
   const book = books.find(b => b.id === bookId);
   if (book) {
       book.status = status;
       if (status === 'finished' && book.pageCount > 0) {
           book.currentPage = book.pageCount;
       }
       if (saveBooks()) {
           renderLibrary();
       }
   }
}

function updateBookRecommendation(bookId, recommendation) {
   const book = books.find(b => b.id === bookId);
   if (book) {
       book.recommendation = book.recommendation === recommendation ? null : recommendation;
       if (saveBooks()) {
           renderLibrary();
       }
   }
}

// Enhanced remove book with confirmation
function removeBook(bookId) {
   const book = books.find(b => b.id === bookId);
   const bookTitle = book ? book.title : 'this book';

   if (confirm(`Are you sure you want to remove "${bookTitle}" from your library?`)) {
       books = books.filter(b => b.id !== bookId);
       if (saveBooks()) {
           renderLibrary();
           showSuccess('Book removed from library');
       }
   }
}

// Enhanced error display
function showError(message) {
   console.error('ERROR:', message);

   // Remove existing errors
   document.querySelectorAll('.error').forEach(el => el.remove());

   const errorDiv = document.createElement('div');
   errorDiv.className = 'error';
   errorDiv.innerHTML = `
       <div>${sanitizeInput(message)}</div>
       <button onclick="this.parentElement.remove()" style="background: transparent; border: 1px solid #cc5500; color: #cc5500; padding: 5px 10px; margin-top: 10px; border-radius: 4px; cursor: pointer;">
           Dismiss
       </button>
   `;

   const scanArea = document.querySelector('#scan-tab > div');
   if (scanArea) {
       scanArea.insertBefore(errorDiv, scanArea.firstChild);
   }

   // Auto-dismiss after 10 seconds
   setTimeout(() => {
       if (errorDiv.parentNode) {
           errorDiv.parentNode.removeChild(errorDiv);
       }
   }, 10000);
}

function showSuccess(message) {
   const successDiv = document.createElement('div');
   successDiv.style.cssText = 'background: #333; color: #cc5500; padding: 15px; border-radius: 8px; margin: 20px; text-align: center; font-weight: bold; border: 1px solid #cc5500;';
   successDiv.textContent = sanitizeInput(message);

   const header = document.querySelector('.header');
   if (header) {
       header.after(successDiv);
   }

   setTimeout(() => {
       if (successDiv.parentNode) {
           successDiv.parentNode.removeChild(successDiv);
       }
   }, 3000);
}

// Enhanced page visibility handling
document.addEventListener('visibilitychange', function() {
   if (document.hidden && scanningActive) {
       debugLog('Page hidden, stopping scanning');
       stopScanning();
   }
});

// Enhanced beforeunload cleanup
window.addEventListener('beforeunload', function() {
   cleanupEventListeners();
   if (scanningActive) {
       stopScanning();
   }
});

// Enhanced page load cleanup
window.addEventListener('load', function() {
   debugLog('üöÄ App fully loaded and cleaned');
   // Clean up any residual states
   isProcessingBarcode = false;
   lastScannedBarcode = null;
   lastScanTime = 0;
});

// Enhanced error boundary for uncaught errors
window.addEventListener('error', function(event) {
   const error = event.error;
   const message = error?.message || 'Unknown error';
   const filename = event.filename || 'Unknown file';
   const lineno = event.lineno || 'Unknown line';

   debugLog(`Uncaught error: ${message} at ${filename}:${lineno}`);
   console.error('Full error details:', {
       message: message,
       filename: filename,
       lineno: lineno,
       colno: event.colno,
       error: error,
       stack: error?.stack
   });

   // Only stop scanning if it's actually running
   if (scanningActive) {
       debugLog('Stopping scanning due to error');
       stopScanning();
   }

   // Only show error for critical issues, not minor ones
   if (message.includes('Quagga') || message.includes('camera') || message.includes('video')) {
       showError('Scanner error occurred. Please try again or refresh the page.');
   }
});

// Enhanced unhandled promise rejection handler
window.addEventListener('unhandledrejection', function(event) {
   const reason = event.reason;
   debugLog('Unhandled promise rejection: ' + reason);
   console.error('Promise rejection details:', reason);

   // Don't show errors for network timeouts or common API failures
   if (typeof reason === 'string' && (
       reason.includes('timeout') || 
       reason.includes('fetch') || 
       reason.includes('network')
   )) {
       debugLog('Network-related promise rejection, not showing error to user');
       event.preventDefault();
       return;
   }

   showError('A processing error occurred. Please try again.');
   event.preventDefault();
});

</script>
</body>
</html>
